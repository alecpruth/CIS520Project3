CIS 520 Project 3: Virtual Memory

---- GROUP ----
Alec Ruth
Travis Atchison
Cre Moore

---- PRELIMINARIES ----


	PAGE TABLE MANAGEMENT
	=====================

---- ALGORITHMS ----
	A1.


---- SYNCHRONIZATION ----
	A2. When a new frame is allocated, the try_frame_alloc_and_lock method in frame.c is eventually called.
In this method, we use a lock to ensure that only one process is allowed to allocate frames at a time.


	PAGING TO AND FROM DISK
	=======================
	
---- ALGORITHMS ----
	B1. When we need to evict a frame, a for loop is used to iterate through all the current frames. For each
frame, we check to see if we can acquire that frame's lock. If we can't, that means the frame is being used elsewhere
and we don't want to evict it, so that frame is skipped. If we can acquire the lock, the next thing we check do is double 
check to make sure that frame is not free/doesn't have a page. If it doesn't have a page, then we assign the page to that frame and 
exit. If the frame does have a page, then we used page_accessed_recently() to determine if the page has recently been used. If it has
been used recently, it is possible it will be used again soon, so we skip that frame. If we find a frame that has a page and hasn't been
used recently, that is the one we swap out.

	B2. We decide this by first confirming that the original page fault was caused by a stack overflow,
then we verify that the given address is below the bottom of the current stack.


	MEMORY MAPPED FILES
	===================
	
---- DATA STRUCTURES ----
	C1. We didn't amke any additions in order to finish the memory mapping implementation. 
The provided implementation had all the functionality we needed, and we simply added the code
necessary to get things working. The methods that we altered/added to were:
syscall.c
	sys_munmap
		The unmap system call. Idenitifies the requested mapping in current list of mappings, then unmaps it.
	unmap
		Removes the given mapping from virtual memory and, if changed, writes back to the file system.

---- ALGORITHMS ----
	C2. Page Fault and eviction process in our code differs between swap pages and other pages because we used the design of 
writing to the swap disk rather then writing to the file when page faulting and evicting. We choose this implementation because it fit 
with the rest of our design choices, but writing to the file would have yeilded the same results. We checked if the page is memory mapped p->file != NULL and if the page has not been modified, if this happened then we wont write to the swap disk otherwise we would. 
	
    C3. We determined that if a new file map overlaps any existing segement by figuring out how many pages are needed for a file.
Once we figured out how many pages are needed, we then allocate for those pages and map them. If we determine that if any entries were written
in more then one page table we new there would be overlap.


----RATIONALE ----
	C4.
